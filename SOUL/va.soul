/*
Virtual analog library.

Zhe Deng 2021
thezhefromcenterville@gmail.com

See https://github.com/thezhe/VirtualAnalogCompressors
*/

/** Title: VA

    Virtual analog library -- a collection of filters (processors and sub-graphs) for discretizing nonlinear inhomogenous ordinary differential equations.

    Notes:
    - All filters are stable and causal.
    - All filters are stable under cutoff modulation, TPT, and SISO unless otherwise indicated.
    - All input and output streams deal with the SampleType (currently only float32 or float 64).
    - All filters have no coefficients unless otherwise indicated.
    - Processors and sub-graphs are designed to be connected in a feedforward fashion.
    - Interface follows style of soul::filters
    - See https://github.com/soul-lang/SOUL/blob/master/source/soul_library/soul_library_filters.soul
*/

namespace VA(using SampleType = float32,
             using CoeffType  = float64,
             int updateInterval = 16)
{
    // namespace typedefs
    namespace filt = soul::filters(SampleType, CoeffType, updateInterval);
    namespace op = soul::filters(SampleType, CoeffType, updateInterval)::tpt::onepole;

    //==============================================================================
    /** Irreversible magnetization cutoff calculator.

        Notes:
        - Maps sample to cutoff.
        - Nonlinear, time-varying, and stateful. 
        - Use with algsig
        - Based on the Jiles-Atherton model
        - Use with manCutoff
        - See https://www.hsu-hh.de/ant/wp-content/uploads/sites/699/2017/10/Holters_jamodel_DAFx16.pdf
    */
    namespace MirrOnepoleCutoff
    {
        /** Holds the filter state. */
        struct State
        {
            SampleType x1;
        }

        /** Resets a filter state. */
        void reset (State& s)
        {
            s.x1 = SampleType();
        }
        
        /** */
        SampleType process(State&s, SampleType x)
        {
            const SampleType y = abs(x - s.x1) * SampleType(0.5);
            s.x1 = x;

            return y;
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType omegadiv2;
        
            void run()
            {
                State s;

                loop
                {
                    omegadiv2 << s.process(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic magnetization cutoff calculator.

        Notes:
        - Maps sample to cutoff.
        - Nonlinear, time-invariant, and stateless.
        - Based on the Froehlich-Kennelley model.
        - Use for nonlinear capacitor or inductor tones. 
    */
    namespace ManCutoff
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
  
        }

        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            CoeffType OmegaLinSqrt;
            CoeffType nonlinearity;
        }

        /** Clears a set of coefficients. */
        void clear (Coeffs& c)
        {
            c.OmegaLinSqrt = CoeffType();
            c.nonlinearity = CoeffType();
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, CoeffType freqHz, CoeffType nonlinearity)
        {
            c.OmegaLinSqrt = sqrt(twoPi * freqHz);
            c.nonlinearity = nonlinearity;
        }

        /**The value of 1/L(V) where L(V) is a nonlinear inductance-voltage relation based on 
        the Froelich-Kennelley anhysteretic B-H relation.
        Based on https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
        */
        SampleType process(SampleType x, Coeffs& c)
        {
            const SampleType OmegaSqrt = SampleType(c.nonlinearity) * abs(x) + SampleType(c.OmegaLinSqrt);
            return  OmegaSqrt * OmegaSqrt;
        }
        
        /** */
        processor Processor(float initialFrequency = filt::defaultFreqHz,
                            float initialNonlinearity = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
            
            input event
            {
                float frequencyIn [[ name: "Frequency", min: filt::minFreqHz, max: filt::maxFreqHz, init: filt::defaultFreqHz, unit: "Hz"]];
                float nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 5000, init: 0 ]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }

            float frequency = initialFrequency;
            float nonlinearity = initialNonlinearity;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();

                loop{
                    if (recalc)
                    {
                        recalc = false;

                        c.update(CoeffType(frequency), CoeffType(nonlinearity));
                    }

                    loop (updateInterval)
                    {
                        const SampleType Omega = process(in, c);

                        out << min(SampleType(filt::normalisedFreqLimit * pi), Omega * SampleType(processor.period * 0.5));
                        
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Clamps a cutoff to the range [0, 0.49 * pi/2] 
    
        Notes:
        - Maps cutoff to cutoff.
        - Nonlinear, time-invariant, stateless.
        - Can set to clamp only the low or high value via the processor parameter
    */
    namespace CutoffClamp
    {
        //Cutoff limits normalized such that Nyquist is pi/2
        const SampleType minCutoff = 0;
        const SampleType maxCutoff = SampleType(filt::normalisedFreqLimit * pi);

        /** Constants for use in specifying the filter mode. */
        namespace Mode 
        {
            let clampAll = 0;
            let clampLow = 1;
            let clampHigh = 2;
        }
    
        /** */
        processor Processor(int initialMode = 0)
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    if const (initialMode == Mode::clampAll)
                        out << clamp(in, minCutoff, maxCutoff);
                    else if const (initialMode == Mode::clampLow)
                        out << max(in, minCutoff);
                    else if const (initialMode == Mode::clampHigh)
                        out << min(in, maxCutoff);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** "Topology preserving transform" one-pole filter with an endpoint for cutoff modulation. 

        Notes:
        - Maps sample and cutoff to sample.
        - Linear, time-varying, and stateful.
        - omegadiv2 is the digital cutoff divided by 2. No checking is done! -- the input must be in the interval [0, pi/2). 
        - See soul::filters::tpt::onepole
    */  
    namespace Onepole
    {
        processor Processor (int initialMode = 0)
        {
            input stream SampleType in;
            input stream  SampleType omegadiv2;
            output stream SampleType out;

            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: 0, text: "Lowpass|Highpass|Allpass"]];
            
            event modeIn (float v) { mode = int (v); }

            int mode = initialMode;
            
            CoeffType omegadiv2ToG(CoeffType x)
            {
                CoeffType g = tan(x);
                return g / (1 + g);
            }

            void run()
            {   
                op::State s;
                op::Coeffs c;
                c.clear ();

                loop
                {
                    c.b = omegadiv2ToG(CoeffType(omegadiv2));
                        
                    if (mode == op::Mode::lowpass)        out << s.processLPF (in, c);
                    else if (mode == op::Mode::highpass)  out << s.processHPF (in, c);
                    else if (mode == op::Mode::allpass)   out << s.processAPF (in, c);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Algebraic sigmoid.
        
        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateless.
    */
    namespace AlgSig
    {
        /** */
        SampleType process(SampleType x)
        {
            return x / (1 + abs(x));
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << process(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Jiles-Atherton model

        M = Mirr + Man

        Notes:
        - Maps sample to sample.
        - Nonlinear, time-varying, and stateful.
        - Output simulates the core magnetization of a nonlinear, hysteretic inductor.
        - 1/Output simulates the charge of a nonlinear, hysteretic capacitor.
    */
    namespace JA
    {
        /** */
        graph Graph
        {
            input stream SampleType in;
            output stream SampleType out;

            
            input
            {
                smoothedGain1.volume dBMirr;
                smoothedGain2.volume dBMan;
            }

            let
            {
                onepoleCutoff =  MirrOnepoleCutoff::Processor;
                onepoleInput = AlgSig::Processor;
                onepole = Onepole::Processor;

                dynamicSum = soul::mixers::DynamicSum(SampleType);
                smoothedGain1 = soul::gain::SmoothedGainParameter(float(0.1));
                smoothedGain2 = soul::gain::SmoothedGainParameter(float(0.1));
            }

            connection
            {
                in -> onepoleInput.in, onepoleCutoff.in;

                onepoleInput.out -> onepole.in;
                onepoleCutoff.omegadiv2 -> onepole.omegadiv2;

                //mix Mirr and Man        
                smoothedGain1.gain -> dynamicSum.gain1;
                smoothedGain2.gain -> dynamicSum.gain2;
                onepoleInput.out -> dynamicSum.in1;
                onepole.out -> dynamicSum.in2;
                  
                dynamicSum.out -> out;
            }
        }
    }

    //==============================================================================
    /** Derivative of the Jiles-Atherton model

        dM/dH = dMirr/dH + dMan/dH

        Notes:
        - Maps sample to cutoff.
        - Nonlinear, time-varying, and stateful.
        - Output simulates the inductance of a nonlinear, hysteretic inductor.
        - 1/Output simulates the capacitance of a nonlinear, hysteretic capacitor.
    */
    namespace JACutoff
    {
        /** */
        graph Graph
        {
            input stream SampleType in;
            output stream SampleType omegadiv2;
    
            input
            {
                manCutoff.frequencyIn frequency;
                manCutoff.nonlinearityIn nonlinearity;

                smoothedGain1.volume dBMirr;
                smoothedGain2.volume dBMan;
            }
    
            let
            {
                manCutoff = ManCutoff::Processor;
                
                mirrOnepoleCutoff =  MirrOnepoleCutoff::Processor;
                mirrOnepoleInput = AlgSig::Processor;
                mirrOnepole = Onepole::Processor(1);

                dynamicSum = soul::mixers::DynamicSum(SampleType);
                smoothedGain1 = soul::gain::SmoothedGainParameter(float(0.1));
                smoothedGain2 = soul::gain::SmoothedGainParameter(float(0.1));

                cutoffClamp = va::CutoffClamp::Processor;
            }
    
            connection
            {
                //mirr cutoff
                in -> mirrOnepoleInput.in, mirrOnepoleCutoff.in;
                mirrOnepoleInput.out -> mirrOnepole.in;
                mirrOnepoleCutoff.omegadiv2 -> mirrOnepole.omegadiv2;
                mirrOnepole.out -> dynamicSum.in1; 

                //man cutoff
                in -> manCutoff.in;
                manCutoff.out -> dynamicSum.in2;

                //mix
                smoothedGain1.gain -> dynamicSum.gain1;
                smoothedGain2.gain -> dynamicSum.gain2;
                
                //clamp
                dynamicSum.out -> cutoffClamp.in;
                cutoffClamp.out -> omegadiv2;
            }
        }
    }

    //==============================================================================
    /** Various rectifier functions.

        Notes:
        - Maps sample to sample
        - Nonlinear, time-invariant, stateless.
    */
    namespace Rectifier
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let peak = 0;
            let halfWave = 1;
            let fullWave = 2;
        }

        /** */
        processor Processor(int initialMode = 0)
        {
            input stream SampleType in;
            output stream SampleType out;
        
            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: 0, text: "Lowpass|Highpass|Allpass"]];
            
            event modeIn (float v) { mode = int (v); }

            int mode = initialMode;

            void run()
            {
                loop
                {
                    if (mode == Mode::peak) { out << abs(in); }
                    else if (mode == Mode::halfWave) { out<<1; }
                    else if (mode == Mode::fullWave) { out << 1; }

                    advance();
                }
            }
        }
        
    }
}

//TODO channel-wise vectorization support
//TODO finish rectifier
//TODO mirr cutoff trapezoidal differentiation?
