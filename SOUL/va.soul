/*
Virtual analog library.

Zhe Deng 2021
thezhefromcenterville@gmail.com

See https://github.com/thezhe/VirtualAnalogCompressors
*/

/** Title: VA

    Virtual analog library -- a collection of filters (processors and sub-graphs) for discretizing nonlinear inhomogenous ordinary differential equations.

    Notes:
    - All filters are stable and causal.
    - All filters are stable under cutoff modulation and SISO unless otherwise indicated.
    - Processors and sub-graphs are designed to be connected in a feedforward fashion.
    - Interface follows the general style of soul::filters except for some minor type modifications:
        * 'SampleType' must be float64, float32 or a vector of float64/float32. This is also used as a 'CoeffType' for soul::filters.
        * 'MonoType' must be float32 or float64. This is for signals that are guaranteed to be mono or stereo-linked.
        * 'updateInterval' default value increased to 32
        * Processors do not have instantiation parameters 
    - See https://github.com/soul-lang/SOUL/blob/master/source/soul_library/soul_library_filters.soul
*/

namespace VA(using SampleType = float64)
{
    static_assert (SampleType.primitiveType.isFloat, "Primitive type of 'SampleType' must be float32 or float64!");
    static_assert ((SampleType.isVector || SampleType.isFloat), "SampleType must be float64, float32, or a vector of float64/float32!")

    // internal constants
    using MonoType = SampleType.primitiveType;
    const int updateInterval = 32;

    // namespace typedefs
    namespace filt = soul::filters(SampleType, SampleType, updateInterval);
    namespace op = soul::filters(SampleType, SampleType, updateInterval)::tpt::onepole;

    //==============================================================================
    /** Irreversible magnetization (Mirr) cutoff calculator.

        Notes:
        - Maps signal to cutoff (i.e. this is a helper namespace; not an effect!).
        - Nonlinear, time-varying, and stateful. 
        - Use with 'Onepole' to calculate Mirr (LPF) or dMirr (HPF).
        - Based on the Jiles-Atherton model.
    */
    namespace MirrOnepoleCutoff
    {
        /** Holds the filter state. */
        struct State
        {
            SampleType x1;
        }

        /** Resets a filter state. */
        void reset (State& s)
        {
            s.x1 = SampleType();
        }
        
        /** */
        SampleType process(State&s, SampleType x)
        {
            const SampleType y = abs(x - s.x1) * SampleType(0.5);
            s.x1 = x;

            return y;
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType omegadiv2;
        
            void run()
            {
                State s;

                loop
                {
                    omegadiv2 << s.process(in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic magnetization curve (Man).
        
        Notes:
        - Maps signal to signal.
        - Nonlinear, time-invariant, stateless.
        - Langevin function approximation.
        - Use as an algebraic sigmoid with input gain.
    */
    namespace Man
    {
        /** */
        SampleType process(SampleType x)
        {
            return x / (SampleType(1.0) + abs(x));
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            input stream SampleType a;
            output stream SampleType out;
            
            void run()
            {
                loop
                {
                    out << process(a * in);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** Derivative of arctangent (datan).
        
        Notes:
        - Maps signal to signal.
        - Nonlinear, time-invariant, stateless.
        - Use an algebraic bell-shaped function or derivative of a sigmoidal function.
        - See https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/1.-differentiation/part-b-implicit-differentiation-and-inverse-functions/session-15-implicit-differentiation-and-inverse-functions/MIT18_01SCF10_Ses15b.pdf
    */
    namespace datan
    {
        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            SampleType w; //width; f(c+w) = 0.5*h
            SampleType h; //height
            SampleType c; //center
        }

        /** Clears a set of coefficients. */
        void clear (Coeffs& c)
        {
            c.w = SampleType(1.0);
            c.h = SampleType();
            c.c = SampleType();
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, MonoType width, MonoType height, MonoType center)
        {
            c.w = MonoType(1.0) / width;
            c.h = height;
            c.c = center;
        }

        /** */
        SampleType process(SampleType x, Coeffs& c)
        {
            const SampleType temp = c.w * (x - c.c);
            return c.h / (SampleType(1.0) + temp * temp);
        }

        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType out;

            input event
            {
                MonoType widthIn [[ name: "Frequency", min: filt::minFreqHz, max: filt::maxFreqHz, init: filt::defaultFreqHz, unit: "Hz" ]];
                MonoType heightIn [[ name: "Nonlinearity", min: 0, max: 5000, init: 0 ]];
                MonoType centerIn [[ name: "Mode", min: 0, max: 1, init: 0, text: "C|L" ]];
            }

            event frequencyIn (MonoType v) { frequency = v; recalc = true; }
            event nonlinearityIn (MonoType v) { nonlinearity = v; recalc = true; }
            event modeIn (MonoType v) { mode = int(v); recalc = true; }

            MonoType frequency = MonoType(filt::defaultFreqHz);
            MonoType nonlinearity = MonoType();
            int mode = initialMode;
            
            void run()
            {   
                Coeffs c;
                c.clear();

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        //c.update
                    }

                    loop (updateInterval)
                    {
                        out << process(in);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Anhysteretic magnetization cutoff -- dMan/dH.

        Notes:
        - Maps sample to cutoff.
        - Nonlinear, time-invariant, and stateless.
        - Use for nonlinear capacitor or inductor tones. 
        - Based on the Froehlich-Kennelley model.
        - See https://www.dafx.de/paper-archive/2015/DAFx-15_submission_68.pdf
    */
    namespace ManCutoff
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let C = 0;
            let L = 1;
        }

        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            SampleType c; //affects linear cutoff
            SampleType b; //affects nonlinearity
        }

        /** Clears a set of coefficients. */
        void clear (Coeffs& c)
        {
            c.c = SampleType();
            c.b = SampleType();
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, MonoType freqHz, MonoType nonlinearity, int mode)
        {
            if (mode == Mode::C)
            {
                c.c = sqrt(MonoType(1.0) / (twoPi * freqHz));
                c.b = nonlinearity;
            }
            else if (mode == Mode::L)
            {
                c.c = sqrt(twoPi * freqHz);
                c.b = nonlinearity;
            }
        }

        /**The value of 1/L(V) where L(V) is a nonlinear inductance-voltage relation based on 
        the Froelich-Kennelley anhysteretic B-H relation.
        Based on 
        */
        SampleType process(SampleType x, Coeffs& c)
        {
            const SampleType OmegaSqrt = c.b * abs(x) + c.c;
            return  SampleType(1.0) / (OmegaSqrt * OmegaSqrt);
        }
        
        /** */
        processor Processor
        {
            input stream SampleType in;
            output stream SampleType Omega;
            
            input event
            {
                MonoType frequencyIn [[ name: "Frequency", min: filt::minFreqHz, max: filt::maxFreqHz, init: filt::defaultFreqHz, unit: "Hz"]];
                MonoType nonlinearityIn [[ name: "Nonlinearity", min: 0, max: 5000, init: 0 ]];
                MonoType modeIn [[ name: "Mode", min: 0, max: 1, init: 0, text: "C|L"]];
            }

            event frequencyIn (MonoType v) { frequency = v; recalc = true; }
            event nonlinearityIn (MonoType v) { nonlinearity = v; recalc = true; }
            event modeIn (MonoType v) { mode = int(v); recalc = true; }

            MonoType frequency = MonoType(filt::defaultFreqHz);
            MonoType nonlinearity = MonoType();
            int mode = initialMode;
            bool recalc = true;

            void run()
            {
                Coeffs c;
                c.clear();

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update(frequency, nonlinearity, mode);
                    }

                    loop (updateInterval)
                    {   
                        Omega << process(in, c);

                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Converts an analog angular cutoff to a digital angular cutoff divided by 2
    
        Notes:
        - Maps cutoff to cutoff.
        - Nonlinear, time-invariant, stateless.
        - Clamping to the interval [0, 0.49 * pi] can be enabled via a processor parameter
    */
    namespace OmegaToomegadiv2
    {
        //Cutoff limits normalized such that Nyquist is pi/2
        const SampleType minCutoff = 0;
        const SampleType maxCutoff = SampleType(filt::normalisedFreqLimit * pi);

        /** Constants for use in specifying the filter mode. */
        namespace Mode 
        {
            let none = 0;
            let clampLow = 1;
            let clampHigh = 2;
            let clampAll = 3;
        }
    
        /** */
        processor Processor(int initialMode = 0, int reciprocal = 0)
        {
            input stream SampleType Omega;
            output stream SampleType omegadiv2;

            void run()
            {
                loop
                {
                    const SampleType temp = reciprocal == 0 ? Omega : 1 / Omega;
                    const SampleType omegadiv2Unclamped = temp * SampleType(processor.period * 0.5);

                    if const (initialMode == Mode::none)
                        omegadiv2 << omegadiv2Unclamped;
                    else if const (initialMode == Mode::clampLow)
                        omegadiv2 << max(omegadiv2Unclamped, minCutoff);
                    else if const (initialMode == Mode::clampHigh)
                        omegadiv2 << min(omegadiv2Unclamped, maxCutoff);
                    else if const (initialMode == Mode::clampAll)
                        omegadiv2 << clamp(omegadiv2Unclamped, minCutoff, maxCutoff);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** "Topology preserving transform" multi-mode one-pole filter with an endpoint for cutoff modulation. 

        Notes:
        - Maps signal and cutoff to signal.
        - Linear, time-varying, and stateful.
        - omegadiv2 is the digital cutoff divided by 2. No checking is done! -- the input must be in the interval [0, pi/2). 
        - See soul::filters::tpt::onepole
    */  
    namespace Onepole
    {
        processor Processor (int initialMode = 0)
        {
            input stream SampleType in;
            input stream  SampleType omegadiv2;
            output stream SampleType out;

            input event float modeIn [[ name: "Mode", min: 0, max: 2, init: 0, text: "Lowpass|Highpass|Allpass"]];
            
            event modeIn (float v) { mode = int (v); }

            int mode = initialMode;
            
            SampleType omegadiv2ToG(SampleType x)
            {
                SampleType g = tan(x);
                return g / (1 + g);
            }

            void run()
            {   
                op::State s;
                op::Coeffs c;
                c.clear ();

                loop
                {
                    c.b = omegadiv2ToG(SampleType(omegadiv2));
                        
                    if (mode == op::Mode::lowpass)        out << s.processLPF (in, c);
                    else if (mode == op::Mode::highpass)  out << s.processHPF (in, c);
                    else if (mode == op::Mode::allpass)   out << s.processAPF (in, c);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** "Topology preserving transform" multi-mode state variable filter (SVF) with endpoints for cutoff and resonance modulation. 

        Notes:
        - Maps signal and cutoff to signal.
        - Linear, time-varying, and stateful.
        - omegadiv2 is the digital cutoff divided by 2. No checking is done! -- the input must be in the interval [0, pi/2). 
        - See soul::filters::tpt::svf
    */  
    namespace SVF
    {
        /** Constants for use in specifying the filter mode. */
        namespace Mode
        {
            let lowpass  = 0;
            let highpass = 1;
            let bandpass = 2;
        }

        /** Holds a set of filter coefficients. */
        struct Coeffs
        {
            CoeffType a0;
            CoeffType a;
            CoeffType p;
        }

        /** Holds the filter state. */
        struct State
        {
            SampleType[2] z;
        }

        /** Resets a filter state. */
        void reset (State& s)
        {
            s.z[0] = SampleType();
            s.z[1] = SampleType();
        }

        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, float64 sampleRate, float64 freqHz, float64 quality)
        {
            let Q = CoeffType (max (quality, 0.001));
            let wd = CoeffType (twoPi * freqHz);
            let T  = CoeffType (1 / sampleRate);
            let wa = (2 / T) * tan (wd * T / 2);
            let g  = wa * T / 2;
            let R = 1 / (2 * Q);
            c.a0 = 1 / (1 + 2 * R * g + g * g);
            c.a = g;
            c.p = 2 * R + g;
        }

        /** */
        SampleType[3] process (State& s, SampleType x, Coeffs& c)
        {
            let hpf = SampleType (c.a0 * (x - c.p * s.z[0] - s.z[1]));
            let bpf = SampleType (c.a * hpf + s.z[0]);
            let lpf = SampleType (c.a * bpf + s.z[1]);

            s.z[0] = SampleType (c.a * hpf + bpf);
            s.z[1] = SampleType (c.a * bpf + lpf);

            return SampleType[3] (lpf, hpf, bpf);
        }

        //SampleType processLPF

        /** */
        processor Processor (float initialFrequency = defaultFreqHz,
                                float initialQuality = defaultQuality)
        {
            input stream SampleType in;
            input stream SampleType omegadiv2, R;
            output stream SampleType out;

            input event
            {
                float frequencyIn [[ name: "Frequency", min: minFreqHz,   max: maxFreqHz, init: defaultFreqHz, unit: "Hz"]];
                float qualityIn   [[ name: "Q",         min: 0.01,        max: 100.0,     init: defaultQuality]];
            }

            event frequencyIn (float v) { frequency = v; recalc = true; }
            event qualityIn   (float v) { quality = v; recalc = true; }

            float frequency = initialFrequency,
                    quality = initialQuality;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
                        let clippedFrequency = clamp (float64 (frequency),
                                                        float64 (minFreqHz),
                                                        processor.frequency * normalisedFreqLimit);
                        c.update (processor.frequency, clippedFrequency, quality);
                    }

                    loop (updateInterval)
                    {
                        let y = s.process (in, c);

                        
                        lowpassOut  << y[0];
                        highpassOut << y[1];
                        bandpassOut << y[2];
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Absolute value processor wrapper.

        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateless.
    */
    namespace Abs
    {
        /** */
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << abs(in);

                    advance();
                }
            }
        }
        
    }

    //==============================================================================
    /** An optimized compressor transfer function with color parameters 
        
        

        Notes:
        - Maps sample to sample.
        - Nonlinear, time-invariant, stateless.
    */
    namespace CTF
    {
        /** Holds a set of filter coefficients. */
        struct Coeffs 
        {
            SampleType thr;
            SampleType divR;
            SampleType height;
            SampleType divWidth; 
        }
    
        /** Clears a set of coefficients. */
        void clear (Coeffs& c) 
        {
            c.thr = SampleType(0.0);
            c.divR = SampleType(1.0);
            c.height = Sample(0.0);
            c.divWidth = SampleType(1.0);
        }
    
        /** Updates a set of coefficients for the given settings. */
        void update (Coeffs& c, MonoType threshold, MonoType ratio, MonoType colorHeight, MonoType colorWidth) 
        {
            c.thr = threshold;
            c.divR = MonoType(1.0) / ratio;
            c.height = colorHeight;
            c.divWidth = MonoType(1.0) / colorWidth;
        }
    
        /** */
        SampleType process (SampleType x, Coeffs& c) 
        {
            const SampleType xdB = soul::gainTodB(x);
            const SampleType color = 0;
            if (x > c.thr)
                return pow(x * c.divThrLin, exponent) * color;
            else
                return color;
        }
    
        /** Processor parameter min/max */
        let
        {
            minThreshold = MonoType(-60.0);
            maxThreshold = MonoType(0.0);
            minRatio = MonoType(1.0);
            maxRatio = MonoType(25.0);
            minColorHeight = MonoType(-5.0);
            maxColorHeight = MonoType(5.0);
            minColorWidth = MonoType(0.2);
            maxColorWidth = MonoType(3.0);
        }

        /** */
        processor Processor(MonoType initialThreshold = -20,
                            MonoType initialRatio = 5,
                            MonoType initialColorHeight = 5,
                            MonoType initialColorWidth = 3)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event
            {
                MonoType thresholdIn [[ name: "Threshold", min: minThreshold, max: maxThreshold, init: initialThreshold, unit: "dB" ]];
                MonoType ratioIn [[ name: "Ratio", min: minRatio, max: maxRatio, init: initialRatio ]];
                MonoType colorHeightIn [[ name: "Color Height", min: minColorHeight, max: maxColorHeight, init: initialColorHeight, unit: "dB" ]];
                MonoType colorWidthIn [[ name: "Color Width", min: minColorWidth, max: maxColorWidth, init: initialColorWidth, unit: "dB" ]];
            }

            event thresholdIn (MonoType v) { threshold = v; recalc = true; }
            event ratioIn (MonoType v) { ratio = v; recalc = true; }
            event colorHeightIn (MonoType v) { colorHeight = v; recalc = true; }
            event colorWidthIn (MonoType v) { colorWidth = v; recalc = true; }

            MonoType threshold = initialThreshold;
            MonoType ratio = initialRatio;
            MonoType colorHeight = initialColorHeight;
            MonoType colorWidth = initialColorWidth;
            bool recalc = true;
    
            void run()
            {
                Coeffs c;
                c.clear();
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update(threshold, ratio, colorHeight, colorWidth);
                    }
    
                    loop (updateInterval)
                    {
                        out << process(in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** Debug implmentations

        Notes:
        - For testing only
        - Filter parameters designed to be set via code rather than gui
    */
    namespace DEBUG
    {
        //==============================================================================
        /** Jiles-Atherton model

            M = Mirr + Man

            Notes:
            - Maps sample to sample.
            - Nonlinear, time-varying, and stateful.
            - Output simulates the core magnetization of a nonlinear, hysteretic inductor.
            - 1/Output simulates the charge of a nonlinear, hysteretic capacitor.
        */
        namespace JA
        {
            /** */
            graph Graph(float initialInputGain = 1,
                        float gainMirr = 0,
                        float gainMan = 1)
            {
                input stream SampleType in;
                output stream SampleType out;

                let
                {
                    mirrOnepoleCutoff =  MirrOnepoleCutoff::Processor;
                    mirrOnepoleInput = Man::Processor(initialInputGain);
                    mirrOnepole = Onepole::Processor;

                    fixedSum = soul::mixers::FixedSum(SampleType, gainMirr, gainMan);
                }

                connection
                {
                    //Mirr
                    in -> mirrOnepoleInput.in, mirrOnepoleCutoff.in;
                    mirrOnepoleInput.out -> mirrOnepole.in;
                    mirrOnepoleCutoff.omegadiv2 -> mirrOnepole.omegadiv2;
                    mirrOnepole.out -> fixedSum.in1;   

                    //Man 
                    mirrOnepoleInput.out -> fixedSum.in2;

                    //Mix
                    fixedSum.out -> out;
                }
            }
        }

        //==============================================================================
        /** Derivative of the Jiles-Atherton model

            dM/dH = dMirr/dH + dMan/dH

            Notes:
            - Maps sample to cutoff.
            - Nonlinear, time-varying, and stateful.
            - Output simulates the inductance of a nonlinear, hysteretic inductor.
            - 1/Output simulates the capacitance of a nonlinear, hysteretic capacitor.
        */
        namespace JACutoff
        {
            /** */
            graph Graph(float initialFrequency = filt::defaultFreqHz, 
                        float initialNonlinearity = 0,
                        int initialMode = 0,
                        float initialInputGain = 1,
                        float gainMirr = 0,
                        float gainMan = 1)
            {
                input stream SampleType in;
                output stream SampleType omegadiv2;
        
                input
                {
                    manCutoff.frequencyIn;
                    manCutoff.nonlinearityIn;
                }

                let
                {
                    manCutoff = ManCutoff::Processor(initialFrequency, initialNonlinearity, initialMode);
                    
                    mirrOnepoleCutoff =  MirrOnepoleCutoff::Processor;
                    mirrOnepoleInput = Man::Processor(initialInputGain);
                    mirrOnepole = Onepole::Processor(1);

                    fixedSum = soul::mixers::FixedSum(SampleType, gainMirr, gainMan);

                    p_OmegaToomegadiv2 = OmegaToomegadiv2::Processor(3, initialMode);
                }
        
                connection
                {
                    //Mirr cutoff
                    in -> mirrOnepoleInput.in, mirrOnepoleCutoff.in;
                    mirrOnepoleInput.out -> mirrOnepole.in;
                    mirrOnepoleCutoff.omegadiv2 -> mirrOnepole.omegadiv2;
                    mirrOnepole.out -> fixedSum.in1;

                    //Man cutoff
                    in -> manCutoff.in;
                    manCutoff.Omega -> fixedSum.in2;

                    //Mode and digital conversion
                    fixedSum.out -> p_OmegaToomegadiv2.Omega;

                    p_OmegaToomegadiv2.omegadiv2 -> omegadiv2;
                }
            }
        }
    }
}

//TODO channel-wise vectorization support
//TODO finish rectifier