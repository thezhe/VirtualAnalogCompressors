## processor

//Lookup Tables
processor test
{
    output event int results;

    using lutType = float[128];

    //Calculate t given the linearly interpolated value y in the range [a, b] and the values of 1/(b-a) and a/(a-b)
    //Option to multiply the result by a scale 
    T invLerp<T> (T divbma, T adivamb, T y, T scale)
    {
        return (y * divbma + adivamb) * scale;
    }

    /** Create a lookup table of function f(x) for values of x in the interval [a,b] using n samples

    - Possible values for f: 1 = dBToGain
    - Use with Math::invLerp and a clamped value if needed
    - Use to set a const array
    */
    lutType createLookupTable(const int f, float a, float b)
    {
       // static_assert(f < 3, "VA::Math::LUT::createLookupTable: Argument f must be an int in interval [1, 3].");

        lutType lut;

        const float divMaxIdx = 1.f / (lut.size - 1.f);

        for(int i = 0; i < lut.size; ++i)
        {
            //integer index elements
            float x = lerp(a, b, i * divMaxIdx);

            //decide function at compile time
           // if const (f == 1)
                lut.at(i) = pow(x, 3.1f);
            // else if (f == 2)
            // {
            //     const float temp = 20*log10(x);
            //     lut.at(i) = temp * temp;
            // } 
        }

        return lut;
    }

    void run()
    {
        //test parameters
        const int f = 1;
        const float a = -60;
        const float b = 0;
        const float T = 0.01f;
        const float avgErrThreshold = 0.0001f;

        //lut parameters
        const float maxIdx = 128 - 1.f;
        const float divbma = 1 / (b - a);
        const float adivamb = a / (a - b);

        lutType dBtoGainLUT = createLookupTable(f, a, b);

        float err = 0;
        float iterations = 0;
        float dummy = 0;
        for (float x = a; x < b; x += T)
        {
            ++iterations;
            const float idx = invLerp(divbma, adivamb, x, maxIdx);

            err += abs(pow(x,3.1f) - dBtoGainLUT.readLinearInterpolated(idx));
            dummy += exp(3.15f * log(x));//dBtoGainLUT.readLinearInterpolated(idx-0.1f);
        }

        let test = float<2>(0);
        let test2 = test[1];
        var test3 = test;
        test3 = 1;
       // results << (err/iterations < avgErrThreshold ? 1 : 0);
        results << (test3[1] == 1 ? 1 : 0);

        loop { advance(); results << -1; } // a -1 must be emitted to make the test terminate
    }
}
