  //     /** Create a lookup table of function OmegaToG() for values of x in the interval [a,b] using n samples
    
                //     - Possible values for f: 1 = L(x), 2 = d2L(x), 3 = d3L(x)
                //     - Use with Math::invLerp and a clamped value if needed
                //     - Use to set a const array
                //     */
                //     T[] createLookupTable<T>(int f, int a, int b, int n)
                //     {
                //         static_assert(f > 0 && f < 6, "va::tpt::onepole::Processor::internal::createLookupTable: Argument f must be an int in interval [0, 1].");

                //         T[n] lut;
                        
                //         T maxIdx = n - 1;

                //         for(int i = 0; i < n; ++i)
                //         {
                //             T x = lerp(a, b, i / maxIdx);

                //             //decide function at compile time
                //             lut.at(i) = OmegaToG(x);
                //         }

                //         return lut;
                //     }

               // }
                    // namespace math
    // {
    //     /** Compressor Transfer FUnction with knee
    //     */
    //     T ctf<T>(T x, T thr, T W, T divR)
    //     {
    //         let xmthr = x - thr;
    //         let xmthr2 = xmthr * 2;

    //         if (xmthr2 < -W)
    //             return x;
    //         else if (xmthr2 > W)
    //             return xmthr * divR + thr;
    //         else //2*abs(x-thr) <= W
    //         {
    //             T temp = 0.5 * W + xmthr;
    //             return (divR - 1) * temp * temp / (2 * W) + x; //x + (divR - 1)*temp*temp/(2*W)
    //         } 
    //     }

    //     //Calculate t given the linearly interpolated value y in the range [a, b] and the values of 1/(b-a) and a/(a-b)
    //     //Option to multiply the result by a scale 
    //     T invLerp<T> (T divbma, T adivamb, T y, T scale)
    //     {
    //         return (y * divbma + adivamb) * scale;
    //     }

    //     /** Create a lookup table of function f(x) for values of x in the interval [a,b] using n samples
        
    //     - Possible values for f: 1 = L(x), 2 = d2L(x), 3 = d3L(x)
    //     - Use with Math::invLerp and a clamped value if needed
    //     - Use to set a const array
    //     */
    //     T[] createLookupTable<T>(int f, int a, int b, int n)
    //     {
    //         static_assert(f > 0 && f < 6, "VA::Math::LUT::createLookupTable: Argument f must be an int in interval [1, 3].");

    //         T[n] lut;
            
    //         T maxIdx = n - 1;

    //         for(int i = 0; i < n; ++i)
    //         {
    //             T x = lerp(a, b, i / maxIdx);

    //             //decide function at compile time
    //             if const (f == 1)
    //                 lut.at(i) = soul::gainTodB(x);
    //             else if const (f == 2)
    //                 lut.at(i) = soul::dBtoGain(x);
    //             else if const (f == 3)
    //                 lut[i] = internal::OmegaToG(x);
    //             else if const (f == 4)
    //                 lut[i] = internal::L(x);
    //             else if const (f == 5)
    //                 lut[i] = internal::d2L(x);
    //         }

    //         return lut;
    //     }

    //     /** Title: internal

    //     Internal functions used in createLookupTable()
    //     Not reccomended for direct use due to high cpu cost
    //     */
    //     namespace internal
    //     {
    //         /** Half wave rectifier function inspired by the Schockley Diode equation
            
    //         - Passes through origin
    //         - Returns slightly negative values for x < 0
    //         - Returns positive values for x > 0
    //         */
    //         T halfWaveRectifier<T>(T x)
    //         {
    //             return (exp(x) - 1) / (exp(1) - 1);
    //         }

    //         /** Full wave rectifier function using va::math::approximations::halfWaveRectifier
            
    //         - Passes through origin
    //         - Returns positive values
    //         */
    //         T fullWaveRectifier<T>(T x)
    //         {
    //             return halfWaveRectifier(abs(x));
    //         }

    //         /** Hyperbolic cotangent */
    //         T cotanh<T>(T x)
    //         {
    //             return 1 / tanh(x);
    //         }

    //         /** Jiles-Atherton Langevin Function
    //         See https://dafx2019.bcu.ac.uk/papers/DAFx2019_paper_3.pdf 
    //         */
    //         T L<T>(T x) 
    //         {
    //             if (abs(x) < 0.0001)
    //                 return x / 3;
    //             return 1 / cotanh(x) - 1 / x;
    //         }

    //     }
    // }
